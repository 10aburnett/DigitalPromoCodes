#!/usr/bin/env node
/* eslint-disable no-console */
const { execSync } = require('child_process');
const { writeFileSync, readFileSync, existsSync } = require('fs');
const path = require('path');

// Never run in CI or production builds
if (process.env.CI || process.env.NODE_ENV === 'production') process.exit(0);

// Optionally load a local, untracked secrets file
// Put your DB URLs in .env.local.secrets (gitignored)
const secretsPath = path.join(process.cwd(), '.env.local.secrets');
if (existsSync(secretsPath)) {
  require('dotenv').config({ path: secretsPath });
}

// Read provider URLs ONLY from local env (never hard-code!)
const PROD_URL   = process.env.LOCAL_PRODUCTION_DATABASE_URL;
const BACKUP_URL = process.env.LOCAL_BACKUP_DATABASE_URL;

if (!PROD_URL || !BACKUP_URL) {
  console.error('\n‚ùå Missing LOCAL_PRODUCTION_DATABASE_URL or LOCAL_BACKUP_DATABASE_URL.');
  console.error('   Add them to a gitignored `.env.local.secrets` or export them in your shell.\n');
  process.exit(1);
}

function getBranch() {
  try {
    return execSync('git rev-parse --abbrev-ref HEAD', { encoding: 'utf8' }).trim();
  } catch {
    console.warn('‚ö†Ô∏è  Could not determine git branch, defaulting to "development".');
    return 'development';
  }
}

function mask(url) {
  try {
    const u = new URL(url);
    if (u.username) u.username = '***';
    if (u.password) u.password = '***';
    return u.toString();
  } catch {
    return 'unparseable-url';
  }
}

function extractHost(url) {
  try { return (new URL(url)).host; } catch { return 'unknown-host'; }
}

// Manual overrides
const args = process.argv.slice(2);
let runtime = null;
let chosen = null;

if (args.includes('--force-production')) {
  chosen = PROD_URL;
  runtime = 'production';
} else if (args.includes('--force-backup')) {
  chosen = BACKUP_URL;
  runtime = 'backup';
} else {
  const branch = getBranch();
  const useProd = branch === 'main';
  chosen = useProd ? PROD_URL : BACKUP_URL;
  runtime = useProd ? 'production' : 'backup';
}

const envPath = path.join(process.cwd(), '.env.local');

// Preserve existing NEXT_PUBLIC_ variables when reading current file
let existingNextPublicVars = [];
if (existsSync(envPath)) {
  try {
    const current = readFileSync(envPath, 'utf8');
    const lines = current.split('\n');
    existingNextPublicVars = lines.filter(line =>
      line.trim() &&
      !line.trim().startsWith('#') &&
      line.includes('NEXT_PUBLIC_')
    );
  } catch { /* ignore */ }
}

const desired = [
  '# Auto-generated by set-env-from-branch.js',
  `DATABASE_URL="${chosen}"`,
  `NEXT_RUNTIME_DATABASE="${runtime}"`,
  ...existingNextPublicVars
].join('\n') + '\n';

// Avoid unnecessary writes - but account for preserved variables
if (existsSync(envPath)) {
  try {
    const current = readFileSync(envPath, 'utf8').trim();
    if (current === desired.trim()) {
      console.log(`‚úÖ .env.local already points to ${runtime} (${extractHost(chosen)})`);
      process.exit(0);
    }
  } catch { /* ignore */ }
}

writeFileSync(envPath, desired, 'utf8');
console.log(`üìù Wrote .env.local ‚Üí ${runtime.toUpperCase()} (${extractHost(chosen)})`);
console.log(`   DATABASE_URL=${mask(chosen)}`);