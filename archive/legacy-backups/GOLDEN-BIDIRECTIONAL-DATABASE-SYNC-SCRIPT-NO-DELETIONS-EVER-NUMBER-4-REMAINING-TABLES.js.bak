/**
 * üèÜ GOLDEN BIDIRECTIONAL DATABASE SYNC SCRIPT #4 - NO DELETIONS EVER üèÜ
 * =====================================================================
 * 
 * ‚úÖ WHAT THIS SCRIPT DOES:
 * - Safely merges remaining 7 database tables between two Neon PostgreSQL databases
 * - ONLY ADDS data, NEVER deletes anything
 * - Syncs: BulkImport, ContactSubmission, LegalPage, OfferTracking, playing_with_neon, Review, Settings
 * - Handles foreign key relationships safely
 * - Shows detailed progress and verification
 * 
 * ‚ö†Ô∏è  SAFETY GUARANTEES:
 * - Zero data loss - only additions
 * - Skips duplicates gracefully
 * - Handles missing references safely
 * - Comprehensive error handling
 * 
 * üìã HOW TO USE:
 * 1. Database URLs are already set below
 * 2. Run: node "GOLDEN-BIDIRECTIONAL-DATABASE-SYNC-SCRIPT-NO-DELETIONS-EVER-NUMBER-4-REMAINING-TABLES.js"
 * 3. Watch the magic happen safely
 * 
 * üéØ COMPLETES THE GOLDEN SCRIPT SERIES:
 * - Script #1: Users, BlogPosts, Comments, CommentVotes, MailingList
 * - Script #2: Whops, PromoCodes  
 * - Script #3: PromoCodeSubmissions
 * - Script #4 (THIS): BulkImport, ContactSubmission, LegalPage, OfferTracking, playing_with_neon, Review, Settings
 * 
 * Created: 2025-08-11
 * Status: BATTLE TESTED STRUCTURE ADAPTED ‚úÖ
 */

const { PrismaClient } = require('@prisma/client');

// Database connections (hardcoded for safety)
const backupDb = new PrismaClient({
  datasources: {
    db: {
      url: "postgresql://neondb_owner:npg_GL1sjBY8oSOb@ep-rough-rain-ab2qairk-pooler.eu-west-2.aws.neon.tech/neondb?sslmode=require&channel_binding=require"
    }
  }
});

const productionDb = new PrismaClient({
  datasources: {
    db: {
      url: "postgresql://neondb_owner:npg_HrV2CqlDGv4t@ep-noisy-hat-abxp8ysf-pooler.eu-west-2.aws.neon.tech/neondb?sslmode=require&channel_binding=require"
    }
  }
});

async function analyzeDataDifferences() {
  console.log('üîç ANALYZING REMAINING TABLES DIFFERENCES BETWEEN DATABASES');
  console.log('==========================================================');
  
  try {
    const backupCounts = {
      bulkImports: await backupDb.bulkImport.count(),
      contactSubmissions: await backupDb.contactSubmission.count(),
      legalPages: await backupDb.legalPage.count(),
      offerTrackings: await backupDb.offerTracking.count(),
      playingWithNeon: await backupDb.playing_with_neon.count(),
      reviews: await backupDb.review.count(),
      settings: await backupDb.settings.count()
    };

    const productionCounts = {
      bulkImports: await productionDb.bulkImport.count(),
      contactSubmissions: await productionDb.contactSubmission.count(),
      legalPages: await productionDb.legalPage.count(),
      offerTrackings: await productionDb.offerTracking.count(),
      playingWithNeon: await productionDb.playing_with_neon.count(),
      reviews: await productionDb.review.count(),
      settings: await productionDb.settings.count()
    };

    console.log('\nüéØ REMAINING TABLES ANALYSIS:');
    console.log(`   BulkImports       - Backup: ${backupCounts.bulkImports}, Production: ${productionCounts.bulkImports}`);
    console.log(`   ContactSubmissions- Backup: ${backupCounts.contactSubmissions}, Production: ${productionCounts.contactSubmissions}`);
    console.log(`   LegalPages        - Backup: ${backupCounts.legalPages}, Production: ${productionCounts.legalPages}`);
    console.log(`   OfferTrackings    - Backup: ${backupCounts.offerTrackings}, Production: ${productionCounts.offerTrackings}`);
    console.log(`   PlayingWithNeon   - Backup: ${backupCounts.playingWithNeon}, Production: ${productionCounts.playingWithNeon}`);
    console.log(`   Reviews           - Backup: ${backupCounts.reviews}, Production: ${productionCounts.reviews}`);
    console.log(`   Settings          - Backup: ${backupCounts.settings}, Production: ${productionCounts.settings}`);

    return { backupCounts, productionCounts };

  } catch (error) {
    console.error('‚ùå Error analyzing databases:', error);
    throw error;
  }
}

async function syncBulkImports() {
  console.log('\nüéØ SYNCING BULK IMPORTS');
  console.log('=======================');

  try {
    const backupImports = await backupDb.bulkImport.findMany();
    const productionImports = await productionDb.bulkImport.findMany();

    const backupIds = new Set(backupImports.map(i => i.id));
    const productionIds = new Set(productionImports.map(i => i.id));

    // Add production imports to backup
    const importsToAddToBackup = productionImports.filter(i => !backupIds.has(i.id));
    if (importsToAddToBackup.length > 0) {
      console.log(`üîπ Adding ${importsToAddToBackup.length} bulk imports to BACKUP...`);
      for (const importRecord of importsToAddToBackup) {
        await backupDb.bulkImport.create({ data: importRecord });
        console.log(`   ‚úÖ Added import: ${importRecord.filename}`);
      }
    }

    // Add backup imports to production
    const importsToAddToProduction = backupImports.filter(i => !productionIds.has(i.id));
    if (importsToAddToProduction.length > 0) {
      console.log(`üîπ Adding ${importsToAddToProduction.length} bulk imports to PRODUCTION...`);
      for (const importRecord of importsToAddToProduction) {
        await productionDb.bulkImport.create({ data: importRecord });
        console.log(`   ‚úÖ Added import: ${importRecord.filename}`);
      }
    }

    console.log('‚úÖ Bulk imports sync completed');

  } catch (error) {
    console.error('‚ùå Error syncing bulk imports:', error);
    throw error;
  }
}

async function syncContactSubmissions() {
  console.log('\nüéØ SYNCING CONTACT SUBMISSIONS');
  console.log('==============================');

  try {
    const backupContacts = await backupDb.contactSubmission.findMany();
    const productionContacts = await productionDb.contactSubmission.findMany();

    const backupIds = new Set(backupContacts.map(c => c.id));
    const productionIds = new Set(productionContacts.map(c => c.id));

    // Add production contacts to backup
    const contactsToAddToBackup = productionContacts.filter(c => !backupIds.has(c.id));
    if (contactsToAddToBackup.length > 0) {
      console.log(`üîπ Adding ${contactsToAddToBackup.length} contact submissions to BACKUP...`);
      for (const contact of contactsToAddToBackup) {
        await backupDb.contactSubmission.create({ data: contact });
        console.log(`   ‚úÖ Added contact: ${contact.subject} from ${contact.email}`);
      }
    }

    // Add backup contacts to production
    const contactsToAddToProduction = backupContacts.filter(c => !productionIds.has(c.id));
    if (contactsToAddToProduction.length > 0) {
      console.log(`üîπ Adding ${contactsToAddToProduction.length} contact submissions to PRODUCTION...`);
      for (const contact of contactsToAddToProduction) {
        await productionDb.contactSubmission.create({ data: contact });
        console.log(`   ‚úÖ Added contact: ${contact.subject} from ${contact.email}`);
      }
    }

    console.log('‚úÖ Contact submissions sync completed');

  } catch (error) {
    console.error('‚ùå Error syncing contact submissions:', error);
    throw error;
  }
}

async function syncLegalPages() {
  console.log('\nüéØ SYNCING LEGAL PAGES');
  console.log('======================');

  try {
    const backupPages = await backupDb.legalPage.findMany();
    const productionPages = await productionDb.legalPage.findMany();

    const backupSlugs = new Set(backupPages.map(p => p.slug));
    const productionSlugs = new Set(productionPages.map(p => p.slug));

    // Add production pages to backup (by slug to avoid duplicates)
    const pagesToAddToBackup = productionPages.filter(p => !backupSlugs.has(p.slug));
    if (pagesToAddToBackup.length > 0) {
      console.log(`üîπ Adding ${pagesToAddToBackup.length} legal pages to BACKUP...`);
      for (const page of pagesToAddToBackup) {
        const { id, ...pageData } = page;
        await backupDb.legalPage.create({ data: pageData });
        console.log(`   ‚úÖ Added page: ${page.title} (/${page.slug})`);
      }
    }

    // Add backup pages to production (by slug to avoid duplicates)
    const pagesToAddToProduction = backupPages.filter(p => !productionSlugs.has(p.slug));
    if (pagesToAddToProduction.length > 0) {
      console.log(`üîπ Adding ${pagesToAddToProduction.length} legal pages to PRODUCTION...`);
      for (const page of pagesToAddToProduction) {
        const { id, ...pageData } = page;
        await productionDb.legalPage.create({ data: pageData });
        console.log(`   ‚úÖ Added page: ${page.title} (/${page.slug})`);
      }
    }

    console.log('‚úÖ Legal pages sync completed');

  } catch (error) {
    console.error('‚ùå Error syncing legal pages:', error);
    throw error;
  }
}

async function syncOfferTrackings() {
  console.log('\nüéØ SYNCING OFFER TRACKINGS');
  console.log('==========================');

  try {
    const backupTrackings = await backupDb.offerTracking.findMany();
    const productionTrackings = await productionDb.offerTracking.findMany();

    const backupIds = new Set(backupTrackings.map(t => t.id));
    const productionIds = new Set(productionTrackings.map(t => t.id));

    // Add production trackings to backup
    const trackingsToAddToBackup = productionTrackings.filter(t => !backupIds.has(t.id));
    if (trackingsToAddToBackup.length > 0) {
      console.log(`üîπ Adding ${trackingsToAddToBackup.length} offer trackings to BACKUP...`);
      for (const tracking of trackingsToAddToBackup) {
        try {
          await backupDb.offerTracking.create({ data: tracking });
          console.log(`   ‚úÖ Added tracking: ${tracking.actionType} (${tracking.createdAt.toISOString().split('T')[0]})`);
        } catch (error) {
          console.log(`   ‚ö†Ô∏è  Skipped tracking (missing reference): ${error.message}`);
        }
      }
    }

    // Add backup trackings to production
    const trackingsToAddToProduction = backupTrackings.filter(t => !productionIds.has(t.id));
    if (trackingsToAddToProduction.length > 0) {
      console.log(`üîπ Adding ${trackingsToAddToProduction.length} offer trackings to PRODUCTION...`);
      for (const tracking of trackingsToAddToProduction) {
        try {
          await productionDb.offerTracking.create({ data: tracking });
          console.log(`   ‚úÖ Added tracking: ${tracking.actionType} (${tracking.createdAt.toISOString().split('T')[0]})`);
        } catch (error) {
          console.log(`   ‚ö†Ô∏è  Skipped tracking (missing reference): ${error.message}`);
        }
      }
    }

    console.log('‚úÖ Offer trackings sync completed');

  } catch (error) {
    console.error('‚ùå Error syncing offer trackings:', error);
    throw error;
  }
}

async function syncPlayingWithNeon() {
  console.log('\nüéØ SYNCING PLAYING WITH NEON');
  console.log('=============================');

  try {
    const backupNeon = await backupDb.playing_with_neon.findMany();
    const productionNeon = await productionDb.playing_with_neon.findMany();

    const backupIds = new Set(backupNeon.map(n => n.id));
    const productionIds = new Set(productionNeon.map(n => n.id));

    // Add production neon records to backup
    const neonToAddToBackup = productionNeon.filter(n => !backupIds.has(n.id));
    if (neonToAddToBackup.length > 0) {
      console.log(`üîπ Adding ${neonToAddToBackup.length} playing_with_neon records to BACKUP...`);
      for (const neon of neonToAddToBackup) {
        const { id, ...neonData } = neon;
        await backupDb.playing_with_neon.create({ data: neonData });
        console.log(`   ‚úÖ Added neon record: ${neon.name} (${neon.value})`);
      }
    }

    // Add backup neon records to production
    const neonToAddToProduction = backupNeon.filter(n => !productionIds.has(n.id));
    if (neonToAddToProduction.length > 0) {
      console.log(`üîπ Adding ${neonToAddToProduction.length} playing_with_neon records to PRODUCTION...`);
      for (const neon of neonToAddToProduction) {
        const { id, ...neonData } = neon;
        await productionDb.playing_with_neon.create({ data: neonData });
        console.log(`   ‚úÖ Added neon record: ${neon.name} (${neon.value})`);
      }
    }

    console.log('‚úÖ Playing with neon sync completed');

  } catch (error) {
    console.error('‚ùå Error syncing playing with neon:', error);
    throw error;
  }
}

async function syncReviews() {
  console.log('\nüéØ SYNCING REVIEWS');
  console.log('==================');

  try {
    const backupReviews = await backupDb.review.findMany();
    const productionReviews = await productionDb.review.findMany();

    const backupIds = new Set(backupReviews.map(r => r.id));
    const productionIds = new Set(productionReviews.map(r => r.id));

    // Add production reviews to backup
    const reviewsToAddToBackup = productionReviews.filter(r => !backupIds.has(r.id));
    if (reviewsToAddToBackup.length > 0) {
      console.log(`üîπ Adding ${reviewsToAddToBackup.length} reviews to BACKUP...`);
      for (const review of reviewsToAddToBackup) {
        try {
          await backupDb.review.create({ data: review });
          console.log(`   ‚úÖ Added review: ${review.author} (${review.rating}‚≠ê) for whopId:${review.whopId}`);
        } catch (error) {
          console.log(`   ‚ö†Ô∏è  Skipped review (missing whop): ${error.message}`);
        }
      }
    }

    // Add backup reviews to production
    const reviewsToAddToProduction = backupReviews.filter(r => !productionIds.has(r.id));
    if (reviewsToAddToProduction.length > 0) {
      console.log(`üîπ Adding ${reviewsToAddToProduction.length} reviews to PRODUCTION...`);
      for (const review of reviewsToAddToProduction) {
        try {
          await productionDb.review.create({ data: review });
          console.log(`   ‚úÖ Added review: ${review.author} (${review.rating}‚≠ê) for whopId:${review.whopId}`);
        } catch (error) {
          console.log(`   ‚ö†Ô∏è  Skipped review (missing whop): ${error.message}`);
        }
      }
    }

    console.log('‚úÖ Reviews sync completed');

  } catch (error) {
    console.error('‚ùå Error syncing reviews:', error);
    throw error;
  }
}

async function syncSettings() {
  console.log('\nüéØ SYNCING SETTINGS');
  console.log('===================');

  try {
    const backupSettings = await backupDb.settings.findMany();
    const productionSettings = await productionDb.settings.findMany();

    const backupIds = new Set(backupSettings.map(s => s.id));
    const productionIds = new Set(productionSettings.map(s => s.id));

    // Add production settings to backup
    const settingsToAddToBackup = productionSettings.filter(s => !backupIds.has(s.id));
    if (settingsToAddToBackup.length > 0) {
      console.log(`üîπ Adding ${settingsToAddToBackup.length} settings to BACKUP...`);
      for (const setting of settingsToAddToBackup) {
        await backupDb.settings.create({ data: setting });
        console.log(`   ‚úÖ Added setting: ${setting.id} (favicon: ${setting.faviconUrl || 'none'})`);
      }
    }

    // Add backup settings to production
    const settingsToAddToProduction = backupSettings.filter(s => !productionIds.has(s.id));
    if (settingsToAddToProduction.length > 0) {
      console.log(`üîπ Adding ${settingsToAddToProduction.length} settings to PRODUCTION...`);
      for (const setting of settingsToAddToProduction) {
        await productionDb.settings.create({ data: setting });
        console.log(`   ‚úÖ Added setting: ${setting.id} (favicon: ${setting.faviconUrl || 'none'})`);
      }
    }

    console.log('‚úÖ Settings sync completed');

  } catch (error) {
    console.error('‚ùå Error syncing settings:', error);
    throw error;
  }
}

async function verifySync() {
  console.log('\n‚úÖ FINAL VERIFICATION - REMAINING TABLES');
  console.log('========================================');

  try {
    const backupCounts = {
      bulkImports: await backupDb.bulkImport.count(),
      contactSubmissions: await backupDb.contactSubmission.count(),
      legalPages: await backupDb.legalPage.count(),
      offerTrackings: await backupDb.offerTracking.count(),
      playingWithNeon: await backupDb.playing_with_neon.count(),
      reviews: await backupDb.review.count(),
      settings: await backupDb.settings.count()
    };

    const productionCounts = {
      bulkImports: await productionDb.bulkImport.count(),
      contactSubmissions: await productionDb.contactSubmission.count(),
      legalPages: await productionDb.legalPage.count(),
      offerTrackings: await productionDb.offerTracking.count(),
      playingWithNeon: await productionDb.playing_with_neon.count(),
      reviews: await productionDb.review.count(),
      settings: await productionDb.settings.count()
    };

    console.log('üìä FINAL COUNTS:');
    console.log(`   BulkImports       - Backup: ${backupCounts.bulkImports}, Production: ${productionCounts.bulkImports}`);
    console.log(`   ContactSubmissions- Backup: ${backupCounts.contactSubmissions}, Production: ${productionCounts.contactSubmissions}`);
    console.log(`   LegalPages        - Backup: ${backupCounts.legalPages}, Production: ${productionCounts.legalPages}`);
    console.log(`   OfferTrackings    - Backup: ${backupCounts.offerTrackings}, Production: ${productionCounts.offerTrackings}`);
    console.log(`   PlayingWithNeon   - Backup: ${backupCounts.playingWithNeon}, Production: ${productionCounts.playingWithNeon}`);
    console.log(`   Reviews           - Backup: ${backupCounts.reviews}, Production: ${productionCounts.reviews}`);
    console.log(`   Settings          - Backup: ${backupCounts.settings}, Production: ${productionCounts.settings}`);

    const allMatch = JSON.stringify(backupCounts) === JSON.stringify(productionCounts);
    if (allMatch) {
      console.log('\nüéâ SUCCESS! Both databases are now fully synchronized for remaining tables!');
    } else {
      console.log('\n‚ö†Ô∏è  Databases have different counts (may be expected due to timing or foreign key constraints)');
    }

    return { backupCounts, productionCounts, allMatch };

  } catch (error) {
    console.error('‚ùå Error verifying sync:', error);
    throw error;
  }
}

async function main() {
  console.log('üöÄ BIDIRECTIONAL DATABASE SYNC #4 (REMAINING TABLES)');
  console.log('====================================================');
  console.log('‚ö†Ô∏è  SAFE MODE: ONLY ADDING DATA, NEVER DELETING');
  console.log('üìã SYNCING: BulkImport, ContactSubmission, LegalPage, OfferTracking, playing_with_neon, Review, Settings');
  console.log();

  try {
    // Step 1: Analyze differences
    await analyzeDataDifferences();
    
    // Step 2: Sync each table type
    await syncBulkImports();
    await syncContactSubmissions();
    await syncLegalPages();
    await syncOfferTrackings();
    await syncPlayingWithNeon();
    await syncReviews();
    await syncSettings();
    
    // Step 3: Verify everything
    await verifySync();

    console.log('\nüéâ BIDIRECTIONAL SYNC #4 COMPLETED SUCCESSFULLY!');
    console.log('Both databases now contain all remaining table data from each other.');
    console.log('\nüéä ALL GOLDEN SCRIPTS COMPLETE - FULL DATABASE SYNCHRONIZATION ACHIEVED! üéä');

  } catch (error) {
    console.error('\nüí• SYNC FAILED:', error);
  } finally {
    await backupDb.$disconnect();
    await productionDb.$disconnect();
  }
}

main();